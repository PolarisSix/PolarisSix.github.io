import { useEffect, useRef } from "react";
import * as THREE from "three";
import { motion } from "framer-motion";

// ------------------------------------------------------------
// NetworkSix – Interface
// Hintergrund: abstrakte Neuronen (Partikel + Verbindungen),
// die sich zu einem 3D‑Hexagon (Hex‑Prisma) hin verbinden.
// ------------------------------------------------------------

export default function NetworkSixInterface() {
  const mountRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const mount = mountRef.current!;

    // Canvas & Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    mount.appendChild(renderer.domElement);

    // Szene & Kamera
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      55,
      mount.clientWidth / mount.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0.4, 7);

    // Leichte Farbflächen für Tiefe
    const bgPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40),
      new THREE.MeshBasicMaterial({
        color: 0x0a0d14,
        transparent: true,
        opacity: 1,
      })
    );
    bgPlane.position.z = -10;
    scene.add(bgPlane);

    // Beleuchtung subtil für Drahtgitter
    const light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(5, 8, 5);
    scene.add(light);
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);

    // --- HEXAGON (Hexagonales Prisma, Drahtgitter) ---
    const hexRadius = 1.8;
    const hexHeight = 0.6;
    const hexGeo = new THREE.CylinderGeometry(hexRadius, hexRadius, hexHeight, 6, 1, true);
    const hexEdges = new THREE.EdgesGeometry(hexGeo);
    const hexMat = new THREE.LineBasicMaterial({ color: 0x6bdcff, transparent: true, opacity: 0.9 });
    const hexWire = new THREE.LineSegments(hexEdges, hexMat);
    scene.add(hexWire);

    // Leichte Innenfläche (sehr transparent)
    const hexShell = new THREE.Mesh(
      hexGeo.clone(),
      new THREE.MeshPhysicalMaterial({
        color: new THREE.Color("#0b2b3a"),
        emissive: new THREE.Color("#062231"),
        metalness: 0.2,
        roughness: 0.9,
        transparent: true,
        opacity: 0.12,
        side: THREE.DoubleSide,
      })
    );
    scene.add(hexShell);

    // --- NEURONS (Partikel) ---
    const NEURON_COUNT = 320;
    const RANGE = 7; // Streuung der Partikel
    const positions = new Float32Array(NEURON_COUNT * 3);
    const velocities = new Float32Array(NEURON_COUNT * 3);

    for (let i = 0; i < NEURON_COUNT; i++) {
      const i3 = i * 3;
      positions[i3 + 0] = (Math.random() - 0.5) * RANGE * 2;
      positions[i3 + 1] = (Math.random() - 0.5) * RANGE * 1.2;
      positions[i3 + 2] = (Math.random() - 0.5) * RANGE * 2;
      velocities[i3 + 0] = (Math.random() - 0.5) * 0.01;
      velocities[i3 + 1] = (Math.random() - 0.5) * 0.012;
      velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
    }

    const neuronGeo = new THREE.BufferGeometry();
    neuronGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    const neuronMat = new THREE.PointsMaterial({
      size: 0.045,
      color: 0xa9e7ff,
      transparent: true,
      opacity: 0.9,
      depthWrite: false,
    });
    const neurons = new THREE.Points(neuronGeo, neuronMat);
    scene.add(neurons);

    // --- CONNECTIONS (Linien zwischen nahen Neuronen + zum Hexagon) ---
    const MAX_CONNECTIONS = 4500;
    const conPositions = new Float32Array(MAX_CONNECTIONS * 3);
    const conColors = new Float32Array(MAX_CONNECTIONS * 3);
    const conGeo = new THREE.BufferGeometry();
    conGeo.setAttribute("position", new THREE.BufferAttribute(conPositions, 3));
    conGeo.setAttribute("color", new THREE.BufferAttribute(conColors, 3));
    const conMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.35 });
    const connections = new THREE.LineSegments(conGeo, conMat);
    scene.add(connections);

    // Zielpunkte am Hexagon (Scheitelpunkte sammeln)
    const hexVerts: THREE.Vector3[] = [];
    hexWire.geometry.computeBoundingSphere();
    const tmpAttr = (hexWire.geometry as THREE.EdgesGeometry).attributes.position as THREE.BufferAttribute;
    for (let i = 0; i < tmpAttr.count; i += 2) {
      const v1 = new THREE.Vector3(
        tmpAttr.getX(i),
        tmpAttr.getY(i),
        tmpAttr.getZ(i)
      );
      const v2 = new THREE.Vector3(
        tmpAttr.getX(i + 1),
        tmpAttr.getY(i + 1),
        tmpAttr.getZ(i + 1)
      );
      hexVerts.push(v1, v2);
    }

    const mouse = new THREE.Vector2(0, 0);
    const onMove = (e: MouseEvent) => {
      const rect = mount.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    };
    window.addEventListener("mousemove", onMove);

    const onResize = () => {
      renderer.setSize(mount.clientWidth, mount.clientHeight);
      camera.aspect = mount.clientWidth / mount.clientHeight;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", onResize);

    let frameId: number;
    const clock = new THREE.Clock();

    function animate() {
      const dt = Math.min(clock.getDelta(), 0.033);

      hexWire.rotation.y += 0.08 * dt;
      hexShell.rotation.y = hexWire.rotation.y;
      const parallax = 0.2;
      camera.position.x = mouse.x * parallax;
      camera.position.y = 0.4 + mouse.y * 0.1;
      camera.lookAt(0, 0, 0);

      const pos = neuronGeo.getAttribute("position") as THREE.BufferAttribute;
      for (let i = 0; i < NEURON_COUNT; i++) {
        const i3 = i * 3;
        let x = pos.getX(i) + velocities[i3 + 0];
        let y = pos.getY(i) + velocities[i3 + 1];
        let z = pos.getZ(i) + velocities[i3 + 2];
        velocities[i3 + 0] += -x * 0.00003;
        velocities[i3 + 1] += -y * 0.00003;
        velocities[i3 + 2] += -z * 0.00003;
        x = THREE.MathUtils.clamp(x, -RANGE, RANGE);
        y = THREE.MathUtils.clamp(y, -RANGE * 0.8, RANGE * 0.8);
        z = THREE.MathUtils.clamp(z, -RANGE, RANGE);
        pos.setXYZ(i, x, y, z);
      }
      pos.needsUpdate = true;

      let ptr = 0;
      let cptr = 0;
      const maxDist = 1.25;
      for (let i = 0; i < NEURON_COUNT; i++) {
        const i3 = i * 3;
        const ax = pos.getX(i);
        const ay = pos.getY(i);
        const az = pos.getZ(i);

        if (i % 11 === 0 && ptr + 6 < MAX_CONNECTIONS * 3) {
          const hv = new THREE.Vector3(0, 0, 0);
          conPositions[ptr++] = ax; conPositions[ptr++] = ay; conPositions[ptr++] = az;
          conPositions[ptr++] = hv.x; conPositions[ptr++] = hv.y; conPositions[ptr++] = hv.z;
          const bias = 0.7;
          conColors[cptr++] = 0.2; conColors[cptr++] = 0.9; conColors[cptr++] = 1.0;
          conColors[cptr++] = 0.2 * bias; conColors[cptr++] = 0.9 * bias; conColors[cptr++] = 1.0 * bias;
        }

        for (let j = i + 1; j < Math.min(i + 24, NEURON_COUNT); j++) {
          const j3 = j * 3;
          const bx = pos.getX(j);
          const by = pos.getY(j);
          const bz = pos.getZ(j);
          const dx = ax - bx, dy = ay - by, dz = az - bz;
          const d2 = dx * dx + dy * dy + dz * dz;
          if (d2 < maxDist * maxDist && ptr + 6 < MAX_CONNECTIONS * 3) {
            const falloff = 1.0 - Math.sqrt(d2) / maxDist;
            conPositions[ptr++] = ax; conPositions[ptr++] = ay; conPositions[ptr++] = az;
            conPositions[ptr++] = bx; conPositions[ptr++] = by; conPositions[ptr++] = bz;
            const a = 0.25 + 0.5 * falloff;
            conColors[cptr++] = 0.4; conColors[cptr++] = 0.8; conColors[cptr++] = 1.0;
            conColors[cptr++] = 0.4 * a; conColors[cptr++] = 0.8 * a; conColors[cptr++] = 1.0 * a;
          }
        }
      }

      conGeo.setDrawRange(0, ptr / 3);
      (conGeo.getAttribute("position") as THREE.BufferAttribute).needsUpdate = true;
      (conGeo.getAttribute("color") as THREE.BufferAttribute).needsUpdate = true;

      renderer.render(scene, camera);
      frameId = renderer.setAnimationLoop(animate) as unknown as number;
    }

    animate();

    return () => {
      window.removeEventListener("resize", onResize);
      window.removeEventListener("mousemove", onMove);
      renderer.setAnimationLoop(null);
      renderer.dispose();
      mount.removeChild(renderer.domElement);
      neuronGeo.dispose();
      conGeo.dispose();
      hexGeo.dispose();
      hexEdges.dispose();
      hexMat.dispose();
      (hexShell.material as THREE.Material).dispose?.();
    };
  }, []);

  return (
    <div className="relative min-h-screen bg-[#0a0d14] text-neutral-100 overflow-hidden">
      <div ref={mountRef} className="absolute inset-0 -z-10" />

      <header className="max-w-6xl mx-auto px-4 py-5 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="h-8 w-8 rounded-xl bg-gradient-to-br from-sky-400 to-cyan-300" />
          <span className="font-semibold tracking-tight">NetworkSix</span>
        </div>
        <nav className="hidden md:flex gap-6 text-sm text-neutral-300">
          <a className="hover:text-white" href="#features">Features</a>
          <a className="hover:text-white" href="#solutions">Solutions</a>
          <a className="hover:text-white" href="#contact">Contact</a>
        </nav>
      </header>

      <main className="max-w-6xl mx-auto px-4 pt-10 pb-24">
        <motion.h1
          initial={{ opacity: 0, y: 16 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="text-4xl md:text-6xl font-semibold tracking-tight"
        >
          Intelligence, Connected.
        </motion.h1>
        <motion.p
          initial={{ opacity: 0, y: 16 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.7, delay: 0.05 }}
          className="mt-4 max-w-2xl text-neutral-300"
        >
          A neural fabric converging into a resilient core. AI × Crypto infrastructure by NetworkSix.
        </motion.p>

        <motion.div
          initial={{ opacity: 0, y: 16 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.75, delay: 0.1 }}
          className="mt-8 flex flex-col sm:flex-row gap-3"
        >
          <a href="#contact" className="inline-flex items-center justify-center rounded-2xl px-5 py-3 text-sm font-medium bg-white text-neutral-900 hover:bg-white/90 transition shadow-lg shadow-white/10">
            Request Access
          </a>
          <a href="#features" className="inline-flex items-center justify-center rounded-2xl px-5 py-3 text-sm font-medium bg-white/5 ring-1 ring-white/10 hover:bg-white/10 transition">
            Explore
          </a>
        </motion.div>

        <section id="features" className="mt-20 grid md:grid-cols-3 gap-4">
          {[
            { title: "AI Research", desc: "Prototyping, inference, retrieval pipelines." },
            { title: "On‑Chain Analytics", desc: "Signals, risk scoring, monitoring." },
            { title: "Security", desc: "Audits, adversarial testing, observability." },
          ].map((f) => (
            <div key={f.title} className="rounded-2xl bg-white/5 ring-1 ring-white/10 p-5">
              <h3 className="font-medium">{f.title}</h3>
              <p className="mt-2 text-sm text-neutral-300">{f.desc}</p>
            </div>
          ))}
        </section>

        <section id="contact" className="mt-16">
          <div className="rounded-2xl bg-white/5 ring-1 ring-white/10 p-6">
            <h2 className="text-xl font-semibold">Get in touch</h2>
            <p className="text-neutral-300 text-sm mt-1">Tell us about your use‑case. We'll reach out with early access details.</p>
            <form className="mt-4 grid md:grid-cols-3 gap-3" onSubmit={(e) => { e.preventDefault(); alert("Thanks! We'll be in touch."); }}>
              <input className="md:col-span-2 w-full rounded-xl bg-neutral-950 placeholder:text-neutral-500 border border-white/10 px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-cyan-400/60" placeholder="you@company.com" type="email" required />
              <button className="rounded-xl px-5 py-3 text-sm font-medium bg-white text-neutral-900 hover:bg-white/90 transition shadow-lg shadow-white/10" type="submit">Request Access</button>
            </form>
          </div>
        </section>
      </main>

      <footer className="max-w-6xl mx-auto px-4 pb-10 pt-6 text-sm text-neutral-400">
        © {new Date().getFullYear()} NetworkSix. All rights reserved.
      </footer>
    </div>
  );
}
